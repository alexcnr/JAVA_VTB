1. Г. Шилдт. Java 8. Полное руководство // 9-е изд.: Пер. с англ. — М.: Вильям с , 2015. — 1 376 с.
```
> javac Sample.java
> java -classpath ".;sqlite-jdbc-(VERSION).jar" Sample   # in Windows
java -classpath ".;sqlite-jdbc-3.36.0.3.jar" Sample
or
> java -classpath ".:sqlite-jdbc-(VERSION).jar" Sample   # in Mac or Linux
/*            ******                        */
https://docs.oracle.сom/javase/9/docs/api/overview-summary.html

*************************
Конструктор - обычный метод, который вызывается при создании объекта!!!!!!!!!!!
private - виден только из этого класса
default    + из любого класса внутри пакета
protected - плюс любой наследник
public

Ststic  поле в классе к нему и подвязано, то есть если наследник его изменит, то изменится везде!!!!

На методы, объявленные как static , накладываются следующие ограничения:
1. Они могут непосредственно вызывать только другие статические методы.
2. Им непосредственно доступны только статические переменные.
3. Они не могут использовать ссылки типа this или super .
Это следствие того, что static-метод не связан ни с одним из объектов.
*****************
Переменные, которые созданы непосредственно в main будут выкинуты из стека самыми последними,
они самые живучие!!!!
ХИП и стек разные вещи. ПОЧИТАТЬ!!!!!
вроде все что создается от объекта, ссылки и др попадает в хип.
Хотя ссылки на обьект могут лежать и в стеке и в хипе, также и примитивы...
Как только метод мы вызвали, он упал в стек, как только метод закончил работу, то из стека его выкинуло.
ПРИ ЭТОМ ВЕСЬ ОСТАЛЬНОЙ КОД ЛЕЖИТ В ХИПЕ
******************************
При создании объектов их поля инициализируется по умолчанию, то есть можно создать объект кота и не задавать ни имени ничего.
**************
Cуперкласс, его наследники   подклассы
Не нужно!!!!!!!   В родителе объявлять поле name  и в наследнике объявлять точно такое же поле
************************************************
class имя подкласса extends имя суперкласса
************
Важно! Для каждого создаваемого класса можно указать только один суперкласс — в Java не
поддерживается множественное наследование. Если суперкласс не указан явно, то класс
наследуется от класса java.lang.Object (в приведенном выше примере класс Animal является
подклассом суперкласса Object ).
*************************
Важно! Абсолютно все классы в Java являются прямыми или косвенными наследниками класса
Object (из пакета java.lang) . Cat является подклассом Animal, а Animal — подкласс Object,
следовательно и Cat — тоже подкласс Object .
*********************************************
Наследник в своем конструкторе первой строкой кода обязан вызвать конструктор родителя
Либо в родителе надо объявить дефолтный пустой конструктор дополнительно
****************************
Абстрактные методы только внутри абстрактных классов. 
Не можем создавать объекты абстрактных классов.
**************************
Если класс наследник сделать абстрактным, то ему не обязательно реализовывать вложенный абстрактный метод родителя.
Любой не абстрактный наследник, должен реализовать все абстрактные методы родителя.
********************************
final - можно писть такие классы и методы, тогда они не могут иметь наследников
public final class Cat     -    пример
*************
        Animal[] CatsAndDogs = {
                new Cat("CatFromlist", "blue", 10),
                new Dog("DogFromlist", "bluedog", 12),
        };
        for (Animal o : CatsAndDogs) {
            o.voice();
        }
но по ссылке на родителя сможем вызвать только те методы, которые есть у родителя, у ЭНИМАЛ

Наследники могут вызывать методы родителей, но не наоборот!!!!
*********************
equals   -   true   значит   значение из хэшкода обязано быть одинаковым
если не тру по иквалсу, то очень не желательно чтобы этот хэшкод совпадал
поэтому поля, которые используются в расчете иквалс, они же должны использоваться и в расчете хешкодов

/*	ИНТЕРФЕЙСЫ                 */
С помощью ключевого слова interface можно полностью абстрагировать интерфейс класса от его
реализации, то есть указать, что именно должен выполнять класс, но не как это делать.
Каждый интерфейс может быть реализован любым количеством классов. Кроме того, один класс может реализовать любое
количество интерфейсов.
Модификатор доступа interface имя интерфейса {
возвращаемый тип имя метода 1 (список аргументов);
возвращаемый тип имя метода 2 (список аргументов);
тип имя переменной 1 = значение;
тип имя переменной 2 = значение;
}

В ИНТЕРФЕЙСАХ ТОЛЬКО АБСТРАКТНЫЕ МЕТОДЫ, и В НИХ НЕ МОЕЖЕТ БЫТЬ ПЕРЕМЕННЫХ,
ЛЮБОЕ ПОДОБНОЕ ПОЛЕ, В СЛУЧАЕ ЕСЛИ ОБЪЯВИТЬ ПЕРЕМЕННУЮ, БУДЕТ public static final
И надо обязательно в классе переопределить поведение тех методов, кторые мы определили в интерфейсах

Интерфейсы наследуются. 
Если не хотим чтобы методы обязательно надо было реализовывать у наследников, то делаем их дефолтными.
default void fly()
    {System.out.println("FLY-FLY");}
	

Интерфейсом мы по сути гарантируем, что данный класс умеет делать то то.
НЕ можем создавать объекты интерфейсов

    static class Human {
        public void drive(Car car){
        }
        public void skate(Skateboard skateboard){

        }
        public void cycle(Bicycle bicycle){

        }
    }
	
	ЭТО БЫЛ ПЛОХОЙ СПОСОЙ МЕТОДЫ ДОБАВЛЯТЬ
	 
	а можно так
	
	        public void drive(Car car){
        }
        public void drive(Skateboard skateboard){

        }
        public void drive(Bicycle bicycle){

        }
		
		
Внутри одного класса можно объявить еще один, и это будет внутренний класс.
Объект внутреннего класса не может существовать без объекта внешнего класса
Он всегда с привязкой к объекту внешнего класса

Есть функциональные интерфейсы, которые содержат только один метод

01.10    -  



